HOST: http://api.theysay.io/v1

--- TheySay AffectR REST API v1: Documentation ---
---

Getting started with TheySay is easy. Explore the AffectR REST API below, and [sign up](http://theysay.io/signup) to 
receive a development key. Have a question? [Read the FAQ](http://theysay.io/faq). Don't know what to 
build? Check out our [Case Studies](http://theysay.io/casestudies).

The platform-agnostic AffectR REST API enables developers to access and mix-and-match our powerful text analysis processors that cover sentiment analysis, speculation detection, part-of-speech 
tagging, dependency parsing, and others. If you're building application that requires text analysis,
then this is the API for you. Imagine building a hotel booking app: bathroom sentiment, entities surrounding the hotel, 
discover sentiment around to topics you did't know existed - all with a few RESTful API calls.

&copy; 2012 TheySay Ltd. All Rights Reserved.

Rate Limiting
-------------
By default, AffectR REST API allows API clients to make a limited number of calls in a given hour. In pracice, this policy will affect your usage 
in a number of different ways. The default rate limit for calls to the REST API varies depending on the authorisation method used 
and whether the method itself requires authentication. If your application exceeds the rate limit, it will receive a HTTP `403` error response code.
The following thresholds apply:

* Unauthenticated calls are permitted up to 30 requests per hour.
* Authenticated calls are permitted up to 3500 requests per hour, and are measured against the token submitted with the request.

JSONP
-----
JSONP or "JSON with padding" is a complement to the base JSON data format. You can add 'padding' by 
including the request parameter `callback`. The returned `Content-Type` will be `application/javascript`.

For example `http://api.theysay.io/v1/sentiment?text=...&callback=processSentiment`.

---

--
Sentiment Analysis

Sentiment, a dimension of non-factuality that is closely related to subjectivity/affect/emotion/moods, reflects the following fundamental poles manifesting psychological evaluation:

* good/positive/pros/favourable/desirable/recommended/thumbs up/...
* bad/negative/cons/unfavourable/undesirable/not recommended/thumbs down/...

You can use the Sentiment Analysis service to discover deep, fine-grained sentiments and opinions in text.
The analysis, output by a human-like sentiment reasoning algorithm, captures both explicit "author sentiment" as well as 
general, implicit "reader-sentiment" beyond opinions that ultimately stems from affective commons sense as well as issues and events that are 
generally considered to be good vs. bad in the world. 
The analysis can target multiple structural levels of text ranging from entire documents to individual entity mentions.
The returned analysis includes majority sentiment labels, fine-grained 3-way positive/neutral/negative sentiment scores, 
and other auxiliary fields.
--
Get document-level sentiment information about the text snippet as a whole.
GET /sentiment?text=I%20really%20like%20theysay
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
{
  "sentiment": {
    "label": "POSITIVE",
    "positive": 0.933,
    "negative": 0.0,
    "neutral": 0.066
  },
  "wordCount": 4
}


Get sentiment information about each sentence in the text snippet. Add the `level=sentence` parameter.
GET /sentiment?text=...&level=sentence
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "end": 21,
  "sentenceIndex": 0,
  "sentiment": {
    "confidence": 0.729,
    "label": "POSITIVE",
    "positive": 0.838,
    "negative": 0.0,
    "neutral": 0.161
  },
  "start": 0,
  "text": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust ."
}, {
  "end": 52,
  "sentenceIndex": 1,
  "sentiment": {
    "confidence": 0.575,
    "label": "NEGATIVE",
    "positive": 0.031,
    "negative": 0.927,
    "neutral": 0.040 
  },
  "start": 22,
  "text": "The individual then receives a small amount of that as salary and the rest as a loan , which because it can technically be recalled , does not attract tax ."
}]


Get sentiment information about each individual entity mentioned in the text snippet. Add the `level=entity` parameter.
GET /sentiment?text=...&level=entity
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "end": 21,
  "headNoun": "Obama",
  "headNounIndex": "1",
  "namedEntityTypes": ["PEOPLE"],
  "salience": 0.9,
  "sentenceIndex": 0,
  "sentiment": {
    "label": "POSITIVE",
    "positive": 0.838,
    "negative": 0.0,
    "neutral": 0.161,
    "confidence": 0.729
  },
  "start": 0,
  "sentence": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust .",
  "sentenceHtml": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust .",
  "text": "President Obama",
  "words": ["President Obama", "Obama"]
}, {
  "end": 21,
  "headNoun": "Obama",
  "headNounIndex": "1",
  "namedEntityTypes": ["LOCATION"],
  "salience": 0.9,
  "sentenceIndex": 0,
  "sentiment": {
    "label": "POSITIVE",
    "positive": 0.838,
    "negative": 0.0,
    "neutral": 0.161,
    "confidence": 0.729
  },
  "start": 0,
  "sentence": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust .",
  "sentenceHtml": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust .",
  "text": "President Obama",
  "words": ["President Obama", "Obama"]
}]


Get sentiment information about how pairs of entities are related in the text snippet. Add the `level=entityrelation` parameter.
GET /sentiment?text=...&level=entityrelation
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "entity1": {
    "head": "Obama"
    "headIndex": 0,
    "text": "President Obama"
  },
  "entity2": {
    "head": "Merkel"
    "headIndex": 0,
    "text": "Angela Merkel"
  },
  "salience": 0.66,
  "sentiment": {
    "confidence": 0.729
    "label": "NEGATIVE",
    "positive": 0,
    "negative": 0.161,
    "neutral": 0.838
  },
  "sentence": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust .",
  "sentenceHtml": "Under it , an individual resigns from their company and any salary they subsequently receive is paid to an offshore trust ."
}]


Get contextual sentence-level sentiment labels for each word in the text snippet, 
accompanied by temporal coordinates that can be used to plot the development (or flow) of sentiment through the text. Add the `level=word` parameter.
GET /sentiment?text=I%20really%20like%20theysay&level=word
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "sentiment": {
    "label": "POSITIVE",
    "timelineY": 1.0
  },
  "wordIndex": 0,
  "text": "I"
}, {
  "sentiment": {
    "label": "POSITIVE",
    "timelineY": 1.0170000000000001
  },
  "wordIndex": 1,
  "text": "really"
}, {
  "sentiment": {
    "label": "POSITIVE",
    "timelineY": 1.033
  },
  "wordIndex": 2,
  "text": "like"
}, {
  "sentiment": {
    "label": "POSITIVE",
    "timelineY": 1.05
  },
  "wordIndex": 3,
  "text": "theysay"
}]


--
Speculation Detection
Speculative content refers directly or indirectly to any 'irrealis' events that are yet to happen. 
Speculative expressions can hence cover events as diverse as predictions, plans, wanting, wishes, waiting, and risks and warnings, to name a few.      
You can use this service to detects speculative expressions in text at the document and sentence level.
The returned analysis contains only identified speculative content.
Any detected subtypes of speculation are denoted with a dot character (e.g. SPECULATION.SUBTYPE).
--
Get an overall speculation score and individual speculation types from a text snippet.
GET /speculation?text=I%20might%20buy%20macbooks
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "speculationScore": 0.75,
  "speculationTypes": ["SPECULATION", "SPECULATION.PLAN"]
}]


Get speculation types for each sentence in the text snippet.  Add the `level=sentence` parameter.
GET /speculation?text=...&level=sentence
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "end": 3,
  "sentenceIndex": 0,
  "speculationType": "",
  "start": 6,
  "text": "I spotted this message on Twitter."
},
{
  "end": 7,
  "sentenceIndex": 1,
  "speculationType": "SPECULATION.WARNING",
  "start": 0,
  "text": "Laptops come with huge health risks!"
}]

--
Part-of-Speech Tagging
Part-of-speech tagging assigns word class types to individual words in text.
--
GET /postag?text=I%20might%20buy%20macbooks
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "posTag": "PRP",
  "posTaggedWord": "I/PRP",
  "sentenceIndex": 0,
  "stem": "I|i",
  "text": "I",
  "wordIndex": 0
}, {
  "posTag": "MD",
  "posTaggedWord": "might/MD",
  "sentenceIndex": 0,
  "stem": "might|may",
  "text": "might",
  "wordIndex": 1
}, {
  "posTag": "VB",
  "posTaggedWord": "buy/VB",
  "sentenceIndex": 0,
  "stem": "buy",
  "text": "buy",
  "wordIndex": 2
}, {
  "posTag": "NNS",
  "posTaggedWord": "macbooks/NNS",
  "sentenceIndex": 0,
  "stem": "macbooks|macbook",
  "text": "macbooks",
  "wordIndex": 3
}]

--
Dependency Parsing
Dependency parsing assigns typed syntactic dependencies between individual words in each sentence in the text.
--
GET /depparse?text=We%20found%20two%20bugs%20in%20your%20app
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "dependency": {
    "predicate": "nsubj(We-0, found-1)",
    "relation": "nsubj"
  },
  "dependent": {
    "stem": "we",
    "text": "We",
    "wordIndex": 0
  },
  "governor": {
    "stem": "find",
    "text": "found",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "root(ROOT, found-1)",
    "relation": "root"
  },
  "dependent": {
    "stem": "find",
    "text": "found",
    "wordIndex": 0
  },
  "governor": {
    "stem": "ROOT",
    "text": "ROOT",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "det(bugs-0, two-1)",
    "relation": "det"
  },
  "dependent": {
    "stem": "two",
    "text": "two",
    "wordIndex": 0
  },
  "governor": {
    "stem": "bug",
    "text": "bugs",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "dobj(found-0, bugs-1)",
    "relation": "dobj"
  },
  "dependent": {
    "stem": "bug",
    "text": "bugs",
    "wordIndex": 0
  },
  "governor": {
    "stem": "find",
    "text": "found",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "prep(found-0, in-1)",
    "relation": "prep"
  },
  "dependent": {
    "stem": "in",
    "text": "in",
    "wordIndex": 0
  },
  "governor": {
    "stem": "find",
    "text": "found",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "det(app-0, your-1)",
    "relation": "det"
  },
  "dependent": {
    "stem": "your",
    "text": "your",
    "wordIndex": 0
  },
  "governor": {
    "stem": "app",
    "text": "app",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "pobj(in-0, app-1)",
    "relation": "pobj"
  },
  "dependent": {
    "stem": "app",
    "text": "app",
    "wordIndex": 0
  },
  "governor": {
    "stem": "in",
    "text": "in",
    "wordIndex": 1
  }
}]