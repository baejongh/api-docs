HOST: http://api.theysay.io/v1

--- TheySay AffectR REST API v1.02: Documentation ---
---

AffectR REST API is a platform-agnostic service which enables developers to access and mix-and-match our powerful text analysis processors that cover sentiment analysis, speculation detection, part-of-speech 
tagging, dependency parsing, and others. 
If you're building an application that cannot do without serious, state-of-the-art text analytics but don't want to delve deep into natural language processing,
then this is the API for you. 

Getting started with AffectR API is easy. Explore the API below, and simply [contact us](mailto:contact@theysayanalytics.com?Subject=AffectR%20API%20Development%20key%20request) to receive a development key. 

Comments, suggestions, or feedback? [Contact us](mailto:contact@theysayanalytics.com?Subject=AffectR%20API%20feedback) - we love to hear from you!

&copy; 2012, 2013 [TheySay](http://www.theysayanalytics.com) Ltd. All Rights Reserved.

Rate Limiting
-------------
By default, AffectR API allows API clients to make a limited number of calls in a given hour. 
In practice, this policy will affect your usage in a number of different ways. 
The default rate limit for calls to the AffectR API varies depending on the authorisation method used and whether the method itself requires authentication. 
If your application exceeds the rate limit, it will receive a HTTP `403` error response code.
The following thresholds apply:

* By default, calls are permitted up to 500 requests per day, and are measured against the username/password combination submitted with each request. 

Responses returned by the API contain information about your usage in the following response header fields: `X-RateLimit-IntervalSecs:`, `X-RateLimit-Limit:`, `X-RateLimit-Remaining:`, and `X-RateLimit-Reset:`. 

For more information about rate limits, [contact us](mailto:contact@theysayanalytics.com?Subject=AffectR%20API%20rate-limit%20enquiry).

Methods
-----
All endpoints support both `GET` and `POST` methods. 
When `GET` is used, all parameters and arguments can be specified in the URL, for example `/sentiment?text=how%20cool%20is%20that!&level=sentence`.
`POST` accepts JSON objects in the request body itself. 

We recommend `POST`, especially with longer text snippets.

JSONP
-----
JSONP or "JSON with padding" is a complement to the base JSON data format. You can add 'padding' by 
including the request parameter `callback`. The returned `Content-Type` will be `application/javascript`.

Example: `http://api.theysay.io/v1/sentiment?text=...&callback=processSentiment`.

GZIP
----
If you want to receive response data in a compressed GZIP format, add `Accept-Encoding: gzip` to your request headers.

API Version Information
----
To obtain version and server information about the current API, call `/version`.

Example: `http://api.theysay.io/version`.

---

--
Sentiment Analysis

Sentiment, a dimension of non-factuality in language that is closely related to subjectivity/affect/emotion/moods/feelings, reflects psychological evaluation with the following fundamental poles:

* good / positive / pros / favourable / desirable / recommended / thumbs up /...
vs
* bad / negative / cons / unfavourable / undesirable / not recommended / thumbs down /...

You can use the Sentiment Analysis service to discover deep, fine-grained sentiments and opinions in text.
The analysis, output by a human-like sentiment reasoning algorithm, captures both explicit "author sentiment" as well as 
general, implicit "reader-sentiment" beyond opinions that ultimately stems from affective commons sense as well as issues and events that are 
generally considered to be good vs. bad in the world.

The analysis can target multiple structural levels of text ranging from entire documents to individual entity mentions.
The returned analysis includes majority sentiment labels, fine-grained 3-way positive/neutral/negative percentage scores, 
and other useful auxiliary fields.

If no `level=` parameter is specified, document-level analysis will be used by default (`level=doc`).
--
Get document-level sentiment information about the text snippet as a whole.
GET /sentiment?text=...
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
{
  "sentiment": {
    "label": "NEGATIVE",
    "positive": 0.17,
    "negative": 0.8230000000000001,
    "neutral": 0.007
  },
  "wordCount": 99
}


Add the `level=sentence` parameter to get sentiment scores for each sentence in the text snippet.
GET /sentiment?text=...&level=sentence
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "sentiment": {
    "label": "POSITIVE",
    "positive": 0.787,
    "negative": 0.16,
    "neutral": 0.053,
    "confidence": 0.668
  },
  "start": 0,
  "end": 36,
  "sentenceIndex": 0,
  "text": "The new French President Francois Hollande wants a '' growth pact '' in Europe - a set of reforms designed to boost European economies and mitigate the pain caused by government spending cuts across the continent ."
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "positive": 0.34700000000000003,
    "negative": 0.627,
    "neutral": 0.026000000000000002,
    "confidence": 0.614
  },
  "start": 37,
  "end": 68,
  "sentenceIndex": 1,
  "text": "All the bad loans made by eurozone banks may need to be cleaned up ( by injecting money into the banks ) because many national governments probably can not afford it ."
}]


Add the `level=entity` parameter to get sentiment scores for each individual entity mentioned in the text snippet.

By default, all analysed entities are returned in the response. If you want to control which entities are included in the response, use the `targets` parameter to specify which entities you want.
The `targets` parameter accepts a list of regular expressions delimited by the `|` (`%7C`) operator, for example `targets=market` or `targets=market%7Cbusiness(es)%3F%7Copportunity%20cost`.

The specified target entities are matched against individual words in each entity NP. If you want the matching to be based on head nouns in entity NPs, add the `matching=head` parameter.
GET /sentiment?text=...&level=entity
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "sentiment": {
    "label": "POSITIVE",
    "positive": 1.0,
    "negative": 0.0,
    "neutral": 0.0,
    "confidence": 0.756
  },
  "start": 2,
  "end": 2,
  "sentence": "'' This collaboration is sending a strong message to all the spammers : Stop sending us spam .",
  "sentenceHtml": "'' This <span class=\"entityMention\">collaboration</span> is sending a strong message to all the spammers : Stop sending us spam .",
  "text": "collaboration",
  "headNoun": "collaboration",
  "headNounIndex": 2,
  "salience": 1.0
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "positive": 0.41200000000000003,
    "negative": 0.588,
    "neutral": 0,
    "confidence": 0.6890000000000001
  },
  "start": 11,
  "end": 11,
  "sentence": "'' This collaboration is sending a strong message to all the spammers : Stop sending us spam .",
  "sentenceHtml": "'' This collaboration is sending a strong message to all the <span class=\"entityMention\">spammers</span> : Stop sending us spam .",
  "text": "spammers",
  "headNoun": "spammers",
  "headNounIndex": 11,
  "salience": 0.7000000000000001
}]


Add the `level=entityaggregate` parameter to get aggregated sentiment scores for entities mentioned in the text snippet. Individual entity mentions are grouped using lowercase head noun matching and scored using weighted sentiment scores.
GET /sentiment?text=...&level=entityaggregate
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:757
< Content-Type: application/json
[{
  "entity": "osborne",
  "frequency": 2,
  "sentiment": {
    "label": "NEGATIVE",
    "positive": 0.0,
    "negative": 0.96,
    "neutral": 0.04,
    "confidence": 0.801
  },
  "salience": 1.0,
  "mentions": [{
    "sentiment": {
      "label": "NEGATIVE",
      "positive": 0.0,
      "negative": 0.851,
      "neutral": 0.149,
      "confidence": 0.775
    },
    "start": 0,
    "end": 1,
    "sentence": "Mr Osborne said the banking system was not working for its customers .",
    "sentenceHtml": " <span class=\"entityMention\">Mr Osborne</span> said the banking system was not working for its customers .",
    "text": "Mr Osborne",
    "headNoun": "Osborne",
    "headNounIndex": 1,
    "salience": 1.0
  }, {
    "sentiment": {
      "label": "NEGATIVE",
      "positive": 0.0,
      "negative": 0.861,
      "neutral": 0.139,
      "confidence": 0.8270000000000001
    },
    "start": 13,
    "end": 13,
    "sentence": "Osborne also said that banks had failed to take responsibility for their actions .",
    "sentenceHtml": " <span class=\"entityMention\">Osborne</span> also said that banks had failed to take responsibility for their actions .",
    "text": "Osborne",
    "headNoun": "Osborne",
    "headNounIndex": 13,
    "salience": 1.0
  }]
}]


Add the `level=entityrelation` parameter to get detailed information about sentiment relations between entities in the text snippet.
GET /sentiment?text=...&level=entityrelation
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
 "entity1": {
    "head": "Avanesov",
    "headIndex": 2,
    "text": "Russian Georgiy Avanesov"
  },
  "entity2": {
    "head": "botnet",
    "headIndex": 17,
    "text": "Bredolab botnet"
  },
  "sentiment": {
    "label": "NEGATIVE",
    "positive": 0.209,
    "negative": 0.523,
    "neutral": 0.268
  },
  "salience": 0.243,
  "sentence": "Russian Georgiy Avanesov was in May sentenced to four years in jail for being behind the Bredolab botnet which was believed to have been generating more than # 80,000 a month in revenue .",
  "sentenceHtml": " <span class=\"entity1\">Russian Georgiy Avanesov</span> was in May sentenced to four years in jail for being behind the <span class=\"entity2\">Bredolab botnet</span> which was believed to have been generating more than # 80,000 a month in revenue ."
}, {
  "entity1": {
    "head": "Avanesov",
    "headIndex": 2,
    "text": "Russian Georgiy Avanesov"
  },
  "entity2": {
    "head": "revenue",
    "headIndex": 32,
    "text": "revenue"
  },
  "sentiment": {
    "label": "POSITIVE",
    "positive": 0.377,
    "negative": 0.314,
    "neutral": 0.309
  },
  "salience": 0.155,
  "sentence": "Russian Georgiy Avanesov was in May sentenced to four years in jail for being behind the Bredolab botnet which was believed to have been generating more than # 80,000 a month in revenue .",
  "sentenceHtml": " <span class=\"entity1\">Russian Georgiy Avanesov</span> was in May sentenced to four years in jail for being behind the Bredolab botnet which was believed to have been generating more than # 80,000 a month in <span class=\"entity2\">revenue</span> ."
}]


Add the `level=word` parameter to obtain contextual sentence-level sentiment labels and positional co-ordinates for individual words in the text snippet.
You can use the returned labels and co-ordinates to plot the temporal development (or flow) of sentiment through the text snippet.
GET /sentiment?text=...&level=word
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.0
  },
  "wordIndex": 0,
  "text": "There"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.004
  },
  "wordIndex": 1,
  "text": "have"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.008
  },
  "wordIndex": 2,
  "text": "been"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.012
  },
  "wordIndex": 3,
  "text": "clashes"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.0170000000000001
  },
  "wordIndex": 4,
  "text": "throughout"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.0210000000000001
  },
  "wordIndex": 5,
  "text": "the"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.025
  },
  "wordIndex": 6,
  "text": "night"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.029
  },
  "wordIndex": 7,
  "text": "in"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.033
  },
  "wordIndex": 8,
  "text": "many"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.037
  },
  "wordIndex": 9,
  "text": "parts"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.042
  },
  "wordIndex": 10,
  "text": "of"
}, {
  "sentiment": {
    "label": "NEGATIVE",
    "timelineY": -1.046
  },
  "wordIndex": 11,
  "text": "Syria"
}, {
  "sentiment": {
    "label": "NEUTRAL",
    "timelineY": -1.046
  },
  "wordIndex": 12,
  "text": "."
}]


--
Speculation Detection
Speculative language describes or refers directly or indirectly to 'irrealis' events that are yet to happen. 
Speculative expressions can hence cover concepts as diverse as future, certainty, doubt, prediction, wanting, wishes, and waiting, to name a few.      
This service detects speculative expressions at the sentence level.
The response contains only 'positive' matches: if no speculative content is detected, the response is [], accordingly.
Any identified subtypes of speculation are denoted with the dot operator (e.g. SPECULATION.SUBTYPE).
--
GET /speculation?text=It's%20probably%20not%20advisable%20to%20use%20it.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "start": 0,
  "end": 8,
  "sentenceIndex": 0,
  "speculationType": "SPECULATION.ADVICE",
  "text": "It 's probably not advisable to use it ."
}]


--
Risk Detection

This sentence-level service detects expressions that describe or refer to risk and danger, either directly or indirectly.
The response contains only 'positive' matches: if no risk expressions are detected, the response is accordingly [].
Any identified subtypes of risk are denoted with the dot operator (e.g. RISK.SUBTYPE).
--
GET /risk?text=Your%20plan%20sounds%20plain%20dangerous%20in%20my%20mind.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "start": 0,
  "end": 8,
  "sentenceIndex": 0,
  "riskType": "RISK",
  "text": "Your plan sounds plain dangerous in my mind."
}]


--
Intent Analysis

This sentence-level service detects expressions pertaining to intent, intentions, plans, and decisions that can be detected in text.
The response contains only 'positive' matches: if no intent expressions are detected, the response is correspondingly [].
Any identified subtypes of intent are denoted with the dot operator (e.g. INTENT.DECISION).
--
GET /intent?text=I%20have%20made%20a%20decision%20to%20purchase%20the%20new%20improved%20camera%20model.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "start": 0,
  "end": 11,
  "sentenceIndex": 0,
  "intentType": "INTENT.DECISION",
  "text": "I have made a decision to purchase the new improved camera model."
}]


--
Named Entity Recognition
This service detects expressions in the text snippet that refer explicitly or implicitly to

* people and humans in general (PEOPLE)
* places and locations (LOCATION)
* organisations and companies (ORGANISATION)
* times and dates (TIMEDATE)
* monetary issues (MONEY)

For each identified expression (which can be a simple or complex Noun Phrase, Adjective Phrase, or Adverb Phrase), the detected Named Entity types are ranked by their salience (most salient first).
--
GET /namedentity?text=...&level=phrase
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "head": "Hollande",
  "headIndex": 5,
  "start": 0,
  "end": 5,
  "sentence": "The new French President Francois Hollande wants a '' growth pact '' in Europe - a set of reforms designed to boost European economies and mitigate the pain caused by government spending cuts across the continent .",
  "sentenceHtml": "The new French President Francois Hollande wants a '' growth pact '' in Europe - a set of reforms designed to boost European economies and mitigate the pain caused by government spending cuts across the continent .",
  "text": "The new French President Francois Hollande",
  "namedEntityTypes": ["PEOPLE"]
}, {
  "head": "area",
  "headIndex": 7,
  "start": 6,
  "end": 15,
  "sentence": "The three lifeboats have been searching an area 25 miles ( 40km ) south of Wick , in the Beatrice oil field , for the two crew who remain missing .",
  "sentenceHtml": "The three lifeboats have been searching an area 25 miles ( 40km ) south of Wick , in the Beatrice oil field , for the two crew who remain missing .",
  "text": "an area 25 miles ( 40km ) south of Wick",
  "namedEntityTypes": ["LOCATION"]
}, {
  "head": "Co-op",
  "headIndex": 1,
  "start": 0,
  "end": 1,
  "sentence": "The Co-op will pay GBP350m upfront and up to an additional # 400m based on the performance of the combined business .",
  "sentenceHtml": "The Co-op will pay GBP350m upfront and up to an additional # 400m based on the performance of the combined business .",
  "text": "The Co-op",
  "namedEntityTypes": ["ORGANISATION"]
}, {
  "head": "shares",
  "headIndex": 31,
  "start": 30,
  "end": 31,
  "sentence": "The resolution for change was filed by Christian Brothers Investment Services ( CBIS ) and members of the Local Authority Pension Fund Forum ( LAPFF ) , organizations that own B shares .",
  "sentenceHtml": "The resolution for change was filed by Christian Brothers Investment Services ( CBIS ) and members of the Local Authority Pension Fund Forum ( LAPFF ) , organizations that own B shares .",
  "text": "B shares",
  "namedEntityTypes": ["MONEY"]
}]


--
Part-of-Speech Tagging
This service assigns word class types to individual words in the text snippet.
The [tagset]() used is largely compatible with the [Penn Treebank Tagset](http://www.cis.upenn.edu/~treebank/).
--
GET /postag?text=I%20might%20buy%20a%20MacBookPro.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "posTag": "PRP",
  "posTaggedWord": "I/PRP",
  "sentenceIndex": 0,
  "stem": "I|i",
  "text": "I",
  "wordIndex": 0
}, {
  "posTag": "MD",
  "posTaggedWord": "might/MD",
  "sentenceIndex": 0,
  "stem": "might|may",
  "text": "might",
  "wordIndex": 1
}, {
  "posTag": "VB",
  "posTaggedWord": "buy/VB",
  "sentenceIndex": 0,
  "stem": "buy",
  "text": "buy",
  "wordIndex": 2
}, {
  "posTag": "DT",
  "posTaggedWord": "a/DT",
  "sentenceIndex": 0,
  "stem": "a",
  "text": "a",
  "wordIndex": 3
}, {
  "posTag": "NNP",
  "posTaggedWord": "MacBookPro/NNP",
  "sentenceIndex": 0,
  "stem": "MacBookPro|macbookpro",
  "text": "MacBookPro",
  "wordIndex": 4
}, {
  "posTag": ".",
  "posTaggedWord": "./.",
  "sentenceIndex": 0,
  "stem": ".",
  "text": ".",
  "wordIndex": 5
}]


--
Shallow Chunk Parsing
This service detects the boundaries of basic syntactic phrases in the text snippet.
For each sentence, simple non-recursive Noun Phrase (NP) and Verb Group (VG) constituents are provided.
--
GET /chunkparse?text=The%20latest%20patch%20will%20probably%20solve%20all%20your%20problems.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:458
< Content-Type: application/json
[{
  "chunk": {
    "chunkType": "",
    "end": 0,
    "sentenceIndex": 0,
    "start": 0,
    "text": "The"
  },
  "head": {
    "posTag": "DT",
    "posTaggedWord": "The/DT",
    "stem": "The",
    "text": "The",
    "wordIndex": 0
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 1,
    "sentenceIndex": 0,
    "start": 1,
    "text": "latest"
  },
  "head": {
    "posTag": "JJS",
    "posTaggedWord": "latest/JJS",
    "stem": "late",
    "text": "latest",
    "wordIndex": 1
  }
}, {
  "chunk": {
    "chunkType": "NP",
    "end": 2,
    "sentenceIndex": 0,
    "start": 0,
    "text": "The latest patch"
  },
  "head": {
    "posTag": "NN",
    "posTaggedWord": "patch/NN",
    "stem": "patch",
    "text": "patch",
    "wordIndex": 2
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 3,
    "sentenceIndex": 0,
    "start": 3,
    "text": "will"
  },
  "head": {
    "posTag": "MD",
    "posTaggedWord": "will/MD",
    "stem": "will",
    "text": "will",
    "wordIndex": 3
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 4,
    "sentenceIndex": 0,
    "start": 4,
    "text": "probably"
  },
  "head": {
    "posTag": "RB",
    "posTaggedWord": "probably/RB",
    "stem": "probably",
    "text": "probably",
    "wordIndex": 4
  }
}, {
  "chunk": {
    "chunkType": "VP",
    "end": 5,
    "sentenceIndex": 0,
    "start": 3,
    "text": "will probably solve"
  },
  "head": {
    "posTag": "VB",
    "posTaggedWord": "solve/VB",
    "stem": "solve",
    "text": "solve",
    "wordIndex": 5
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 6,
    "sentenceIndex": 0,
    "start": 6,
    "text": "all"
  },
  "head": {
    "posTag": "PDT",
    "posTaggedWord": "all/PDT",
    "stem": "all",
    "text": "all",
    "wordIndex": 6
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 7,
    "sentenceIndex": 0,
    "start": 7,
    "text": "your"
  },
  "head": {
    "posTag": "PRP$",
    "posTaggedWord": "your/PRP$",
    "stem": "your",
    "text": "your",
    "wordIndex": 7
  }
}, {
  "chunk": {
    "chunkType": "NP",
    "end": 8,
    "sentenceIndex": 0,
    "start": 6,
    "text": "all your problems"
  },
  "head": {
    "posTag": "NNS",
    "posTaggedWord": "problems/NNS",
    "stem": "problem",
    "text": "problems",
    "wordIndex": 8
  }
}, {
  "chunk": {
    "chunkType": "",
    "end": 9,
    "sentenceIndex": 0,
    "start": 9,
    "text": "."
  },
  "head": {
    "posTag": ".",
    "posTaggedWord": "./.",
    "stem": ".",
    "text": ".",
    "wordIndex": 9
  }
}]


--
Dependency Parsing
This service analyses the grammatical structure of each sentence in the text snippet.
For each sentence, typed syntactic dependencies between individual words are provided.
The parses and the [typed dependencies]() used resemble the labels and types described in the [Cambridge Grammar of the English Language](http://www.cambridge.org/uk/linguistics/cgel/).
--
GET /depparse?text=I%20got%20a%20new%20camera%20which%20takes%20brilliant%20photos.
> Accept: application/json
< 200
< Access-Control-Allow-Origin:*
< Content-Length:91
< Content-Type: application/json
[{
  "dependency": {
    "predicate": "nsubj(got, I)",
    "relation": "nsubj"
  },
  "dependent": {
    "text": "I",
    "stem": "I|i",
    "wordIndex": 0
  },
  "governor": {
    "text": "got",
    "stem": "got|get",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "(root, got)",
    "relation": ""
  },
  "dependent": {
    "text": "got",
    "stem": "got|get",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "det(camera, a)",
    "relation": "det"
  },
  "dependent": {
    "text": "a",
    "stem": "a",
    "wordIndex": 2
  },
  "governor": {
    "text": "camera",
    "stem": "camera",
    "wordIndex": 4
  }
}, {
  "dependency": {
    "predicate": "amod(camera, new)",
    "relation": "amod"
  },
  "dependent": {
    "text": "new",
    "stem": "new",
    "wordIndex": 3
  },
  "governor": {
    "text": "camera",
    "stem": "camera",
    "wordIndex": 4
  }
}, {
  "dependency": {
    "predicate": "dobj(got, camera)",
    "relation": "dobj"
  },
  "dependent": {
    "text": "camera",
    "stem": "camera",
    "wordIndex": 4
  },
  "governor": {
    "text": "got",
    "stem": "got|get",
    "wordIndex": 1
  }
}, {
  "dependency": {
    "predicate": "rel(takes, which)",
    "relation": "rel"
  },
  "dependent": {
    "text": "which",
    "stem": "which",
    "wordIndex": 5
  },
  "governor": {
    "text": "takes",
    "stem": "takes|take",
    "wordIndex": 6
  }
}, {
  "dependency": {
    "predicate": "rcmod(camera, takes)",
    "relation": "rcmod"
  },
  "dependent": {
    "text": "takes",
    "stem": "takes|take",
    "wordIndex": 6
  },
  "governor": {
    "text": "camera",
    "stem": "camera",
    "wordIndex": 4
  }
}, {
  "dependency": {
    "predicate": "amod(photos, brilliant)",
    "relation": "amod"
  },
  "dependent": {
    "text": "brilliant",
    "stem": "brilliant",
    "wordIndex": 7
  },
  "governor": {
    "text": "photos",
    "stem": "photos|photo",
    "wordIndex": 8
  }
}, {
  "dependency": {
    "predicate": "dobj(takes, photos)",
    "relation": "dobj"
  },
  "dependent": {
    "text": "photos",
    "stem": "photos|photo",
    "wordIndex": 8
  },
  "governor": {
    "text": "takes",
    "stem": "takes|take",
    "wordIndex": 6
  }
}, {
  "dependency": {
    "predicate": "(root, .)",
    "relation": ""
  },
  "dependent": {
    "text": ".",
    "stem": ".",
    "wordIndex": 9
  }
}]
